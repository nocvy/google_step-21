## 宿題1
### 問題
> 行列積のループ順序としては6種類の組合せがある。この6種類を実行速度が速いと思う方から順に並べてください。実際に実験してその予想が正しいかどうか確かめてください。
> - i-j-k, i-k-j, j-i-k, j-k-i, k-i-j, k-j-i
 
### 解答
まず予想は、アクセスが全て連続になる**i-k-j**と**k-i-j**、アクセスが一箇所連続にならない**i-j-k**と**j-i-k**、アクセスが二箇所連続にならない**k-j-i**と**j-k-i**の順に速いと思いました。

N = 1000で実際に実験すると以下の表のような結果になりました。

|  | 1回目 | 2回目 | 3回目 |
----|----|----|----
| i-k-j | 2.433604 sec | 2.458309 sec | 2.547694 sec |
| k-i-j | 2.473426 sec | 2.469264 sec | 2.525199 sec |
| i-j-k | 3.484512 sec | 3.561709 sec | 3.543275 sec |
| j-i-k | 3.470771 sec | 3.613186 sec | 3.557544 sec | 
| k-j-i | 2.962935 sec | 3.117558 sec | 3.101900 sec |
| j-k-i | 3.148472 sec | 3.047806 sec | 3.116557 sec | 

**i-k-j**と**k-i-j**が最も速いのは予想通りでしたが、**i-j-k**と**j-i-k**、**k-j-i**と**j-k-i**の組は予想に反し速さは逆になりました。  
(理由がなぜかはわかりません...)

<br>

<br>

## 宿題2
### 問題
> C/C++/Java/Goで行列積を書くと、i-k-jループのほうがi-j-kループよりもずっと速かった。でも、実はPythonで書くと、ループ順序を入れ替えても速度差はほとんどない。ここまでの説明をふまえて、その理由を考えてください。
 
### 解答
Pythonでは実行時間のうち構文木を評価する過程に多く時間を割いていて、パレートの法則のように(プログラム内の話ではないので少し違うかもしれませんが)、キャッシュヒット率を高めても全体の速度にはあまり影響しないのではないかと考えました。

<br>

<br>

## 宿題3 (総合課題 〜帰ってきたTSP Challenge〜)
### 問題
>これまでの7回の授業で学んできたことを総合して、TSP Challengeのプログラムを最適化して、Challenge 6 (都市数=2048)のベストスコア更新とChallenge 7 (都市数=8192)のベストスコアを目指してください！！
> - Challenge 6には40000以下の答えが存在します

> 他の人のプログラムを利用してもOKです。より賢くしましょう！
> - 他の人が書いたコードを読むのは良い学びになります
> - ネット上にあるTSPソルバなどを使うのは禁止です

### 解答
最初 (week5) の状態 -> greedy + 2-opt法  
これをさらに最適化する方法として、以下の三つを考えました。
1. 言語をPythonからC++に変更する
2. or-opt法(部分列移動)を実装する
3. スタート位置を変えて最も良いものを探す

<br>

### 1. 言語をPythonからC++に変更する
これから色々なアルゴリズムを実装していくにあたって、実行時間を短縮するために言語をC++に変えようと考えました。が、自分のコードをPythonからC++に落とし込む過程で早速挫折してしまったので、C++の最適化オプションで実験してみた結果を書きます。

#### 実行方法
```
% g++ solver.cpp -Ox -o solver
% ./solver
```
今回は x = 0, 1, 3でおおよその時間を測ってみました。

|  | -O0(最適化なし) | -O1(基本的な最適化) | -O3(全ての最適化) |
----|:----:|:----:|:----:
| input_6 | 3分 | 2分 | 10秒 |
| input_7 | 30分以上 | 30分以上 | 15分 |

このように最適化を強くしていくほど実行時間に改善が見られることが確認できました。

C++のコードは [Sakura Shinjiさんのコード](https://github.com/sakutama-11/STEP21/blob/master/class5/tsp_greedy_2opt.cpp)をお借りしました！

<br>

### 2. or-opt法(部分列移動)を実装する
2-opt法で交差を取り除いた後、(a)から(b)のようにルートを変更できるようなor-opt法(部分列移動)を組み込みました。

![IMG_29958340206A-1](https://user-images.githubusercontent.com/63783021/123883949-099b9100-d985-11eb-8aa1-25af4ccc9997.jpeg)

#### 実行方法
```
% python3 solver_oropt.py input_x.csv  // x = 0 ~ 7
```

[Hinako Katafuchiさんのコード](https://gist.github.com/chikochan/0e4312c08aca4bdd44586a4914fce878)のmove_subsequence関数を参考にさせていただきました！

subsequence_lengthは初め10〜1個を順に見ていく形で試したところ実行がなかなか終わらなかったので、7〜1個を順に見ていくようにしました。他は試していませんが、この部分を変更することでもっと最適化できる可能性もあると思います。

<br>

### 3. スタート位置を変えて最も良いものを探す
greedy法で最初の経路を決定するにあたって、スタート位置によって経路が変わってくるので、スタート位置を0からさまざまな点に変更して結果が最も良いものを選択することにしました。  

Nが小さい時は全ての点について調べればいいですが、大きくなってくると実行時間が膨大になり終わらないため 513 < N <= 2048 (つまりinput_6) の時は0とランダムに指定した10個の点、 2049 < N (つまりinput_7) の時は0とランダムに指定した3個の点についてのみ調べることとします。

#### 実行方法
```
% python3 solver_start.py input_x.csv  // x = 0 ~ 7
```
input_6は1分半、input_7は30分ほどかかります。

スタート位置を他の点でも調べられるようにする拡張は [Haruka Akishimaさんのコード](https://github.com/koomin-1122/STEP/blob/main/class5/greedy_2opt_start.py)を参考にしました！

<br>

### スコア比較

|  | | greedy + 2opt (week5) | + or-opt (solver_oropt) | + startchange (solver_start) |
|----|----|:----:|:----:|:----:
| input_0 | N=5 | 3418.10 | **3291.62** | **3291.62** |
| input_1 | N=8 | 3832.29 | **3778.72** | **3778.72** |
| input_2 | N=16 | 5065.58 | **4494.42** | **4494.42** |
| input_3 | N=64 | 8773.35 | 8577.47 | **8122.27** |
| input_4 | N=128 | 11459.46 | 10968.64 | **10601.83** |
| input_5 | N=512 | 21838.68 | **20552.45** | 20582.23 |
| input_6 | N=2048 | 42376.81 | 41051.75 | **40606.32** |
| input_7 | N=8192 | 84693.01 | **81505.62** | **81505.62** |

input_6とinput_7に関しては0以外ランダムにスタート位置を決めているので、数回試してみました。  
input_6は40606.32が一番スコアが良く、input_7は4つの経路しか比較していないため0がスタートである81505.62のスコアに収束することが多かったです。

<br>

### さらに改善できそうな所
C++での実装や、分割による並列化を実装できれば3の方法でランダムに点を指定することなく全ての点について調べても実行時間が現実的な範囲内で収まるのではないかと思いました。  
また2と3の組み合わせで greedy + 2-opt をした段階のスコアを比較していましたが、実行時間に余裕があれば greedy + 2-opt + or-opt をした段階のスコアを比較するようにするとより精度が上がるのではないかと思います。
