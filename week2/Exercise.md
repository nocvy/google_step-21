
## 宿題1

### 問題  
> 行列積を求めるプログラムを書いて、行列のサイズNと実行時間の関係を調べてみよう

### 解答  
書いたプログラムMatrix.cでは行列積を求める部分の時間計算量はO(n^3)である。

Nを変えながら実行時間を調べたところ、結果は以下のようになった。  
（※実行時間は5回実行したものの平均を採用）

###
| N | 実行時間(s) |
|---:|---:|
| 0 | 0.0000018 |
| 5 | 0.0000030 |
| 10 | 0.0000560 |
| 50 | 0.0005906 |
| 100 | 0.0046920 |
| 500 | 0.4516892 |
| 1000 | 3.5283868 |
| 2000 | 29.9647298 |  

###
これをグラフにするとこのようになる。  
（実線が実際のデータ、点線が3次の多項式近似）

###
<img width="500" alt="image" src="https://user-images.githubusercontent.com/63783021/118840964-d1734e00-b902-11eb-8a3b-9d79f06d4ded.png">  

###
今回はN=2000まで実行したが、Nを増やしていくと以下のように指数関数的に実行時間が増えていくと予想できる。  

###
<img width="500" alt="image" src="https://user-images.githubusercontent.com/63783021/118841657-7726bd00-b903-11eb-92cd-70a06d05128d.png">


## 宿題2

### 問題
> 木構造を使えばO(log N)、ハッシュテーブルを使えばほぼO(1)で検索・追加・削除を実現することができて、これだけ見ればハッシュテーブルのほうがはるかに優れているように見える。ところが、現実の大規模なデータベースでは、ハッシュテーブルではなく木構造が使われることが多い。その理由を考えよ。

### 解答
- 現実のデータベースではデータに偏りがあり、ハッシュの衝突が頻繁に起きると考えられるから。  
- 検索効率を上げるためには配列を大きめにとっておく必要があり、大量のメモリを必要とするから。


## 宿題3

### 問題
> 次の操作をほぼO(1)で実現するデータ構造を考えよう
> - 与えられた<URL, Webページ>があるかないかを検索する
> - もしない場合、キャッシュ内で一番古い<URL, Webページ>を捨てて、かわりに与えられた<URL, Webページ>を追加する

### 解答
ハッシュテーブルと双方向連結リストを組み合わせれば良い。

- 与えられた<URL, Webページ>があるかないかを検索する  
 --> ハッシュ値を計算し、その場所にデータがあるかどうかを見る（計算量はほぼO(1)）

- もしない場合、キャッシュ内で一番古い<URL, Webページ>を捨てて、かわりに与えられた<URL, Webページ>を追加する  
 --> 一番古いデータはリストの先頭にあるのでそれを削除し（O(1)）、リストの末尾に新しいデータを追加する（O(1)）
 
- もしある場合、該当の<URL, Webページ>を最新に更新する  
 --> ハッシュで該当のデータにアクセスし削除する（O(1)）、さらに末尾に新しいデータを追加する（O(1)）
